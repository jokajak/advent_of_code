#!/usr/bin/env python
"""Solutions for AoC 9, 2022."""
# Created: 2022-12-09 13:28:56.052840

import math

# Standard library imports
from aocd.models import Puzzle


def parse(input_data):
    """Transform the data"""
    movements = []
    for line in input_data.splitlines():
        movement, distance = line.split(" ")
        movements.append((movement, int(distance)))
    return movements


def calculate_new_position(start_position, movement):
    """Calculate a new position after processing a movement command."""
    # command = (delta_x, delta_y)
    direction = {
        "R": (1, 0),
        "U": (0, 1),
        "D": (0, -1),
        "L": (-1, 0),
    }
    # Given a start position, calculate the finish new position
    delta_x, delta_y = direction[movement]
    x, y = start_position
    return (
        x + delta_x,
        y + delta_y,
    )


def calculate_tail_position(head_position, tail_position):
    """Calculate the new position that the tail should be in.

    If the head is ever two steps directly up, down, left, or right from
    the tail, the tail must also move one step in that direction so it
    remains close enough:

    Otherwise, if the head and tail aren't touching and aren't in the same
     row or column, the tail always moves one step diagonally to keep up:
    """
    head_x, head_y = head_position
    tail_x, tail_y = tail_position
    delta_x, delta_y = 0, 0
    delta_x = head_x - tail_x
    delta_y = head_y - tail_y
    total_delta = abs(delta_x) + abs(delta_y)
    total_delta = math.sqrt(delta_x * delta_x + delta_y * delta_y)
    if total_delta < 2:
        return tail_position
    if delta_x == 0:
        # Normalize values to be 1
        delta_y = int(delta_y / abs(delta_y))
        return (tail_x, tail_y + delta_y)
    elif delta_y == 0:
        # Normalize values to be 1
        delta_x = int(delta_x / abs(delta_x))
        return (tail_x + delta_x, tail_y)
    else:
        # Normalize values to be 1
        delta_y = int(delta_y / abs(delta_y))
        delta_x = int(delta_x / abs(delta_x))
        return (tail_x + delta_x, tail_y + delta_y)


def calculate_visited_positions(start_position, movements):
    """Calculate the positions visited in a movement"""
    # movement is (direction, count)
    visited_positions = {start_position: 1}
    head_position = start_position
    tail_position = start_position
    for movement in movements:
        direction, count = movement
        for i in range(0, count):
            head_position = calculate_new_position(head_position, direction)
            new_tail_position = calculate_tail_position(
                head_position, tail_position)
            if new_tail_position == tail_position:
                continue
            else:
                tail_position = new_tail_position
            if tail_position in visited_positions:
                visited_positions[tail_position] += 1
            else:
                visited_positions[tail_position] = 1
    return visited_positions


def solve_part_one(input_data):
    """Solve part one.

        # --- Day 9: Rope Bridge ---
    This rope bridge creaks as you walk along it. You aren't sure how old
    it is, or whether it can even support your weight.
    It seems to support the Elves just fine, though. The bridge spans a
    gorge which was carved out by the massive river far below you.
    You step carefully; as you do, the ropes stretch and twist. You decide
     to distract yourself by modeling rope physics; maybe you can even
    figure out where *not* to step.
    Consider a rope with a knot at each end; these knots mark the *head*
    and the *tail* of the rope. If the head moves far enough away from the
     tail, the tail is pulled toward the head.
    Due to nebulous reasoning involving [Planck
    lengths](https://en.wikipedia.org/wiki/Planck_units#Planck_length),
    you should be able to model the positions of the knots on a two-
    dimensional grid. Then, by following a hypothetical *series of
    motions* (your puzzle input) for the head, you can determine how the
    tail will move.
    *Due to the aforementioned Planck lengths*, the rope must be quite
    short; in fact, the head (`H`) and tail (`T`) must *always be
    touching* (diagonally adjacent and even overlapping both count as
    touching):
    ```
    ....
    .TH.
    ....
    ....
    .H..
    ..T.
    ....
    ...
    .H. (H covers T)
    ...
    ```
    If the head is ever two steps directly up, down, left, or right from
    the tail, the tail must also move one step in that direction so it
    remains close enough:
    ```
    .....    .....    .....
    .TH.. -> .T.H. -> ..TH.
    .....    .....    .....
    ...    ...    ...
    .T.    .T.    ...
    .H. -> ... -> .T.
    ...    .H.    .H.
    ...    ...    ...
    ```
    Otherwise, if the head and tail aren't touching and aren't in the same
     row or column, the tail always moves one step diagonally to keep up:
    ```
    .....    .....    .....
    .....    ..H..    ..H..
    ..H.. -> ..... -> ..T..
    .T...    .T...    .....
    .....    .....    .....
    .....    .....    .....
    .....    .....    .....
    ..H.. -> ...H. -> ..TH.
    .T...    .T...    .....
    .....    .....    .....
    ```
    You just need to work out where the tail goes as the head follows a
    series of motions. Assume the head and the tail both start at the same
     position, overlapping.
    For example:
    ```
    R 4
    U 4
    L 3
    D 1
    R 4
    D 1
    L 5
    R 2
    ```
    This series of motions moves the head *right* four steps, then *up*
    four steps, then *left* three steps, then *down* one step, and so on.
    After each step, you'll need to update the position of the tail if the
     step means the head is no longer adjacent to the tail. Visually,
    these motions occur as follows (`s` marks the starting position as a
    reference point):
    ```
    == Initial State ==
    ......
    ......
    ......
    ......
    H.....  (H covers T, s)
    == R 4 ==
    ......
    ......
    ......
    ......
    TH....  (T covers s)
    ......
    ......
    ......
    ......
    sTH...
    ......
    ......
    ......
    ......
    s.TH..
    ......
    ......
    ......
    ......
    s..TH.
    == U 4 ==
    ......
    ......
    ......
    ....H.
    s..T..
    ......
    ......
    ....H.
    ....T.
    s.....
    ......
    ....H.
    ....T.
    ......
    s.....
    ....H.
    ....T.
    ......
    ......
    s.....
    == L 3 ==
    ...H..
    ....T.
    ......
    ......
    s.....
    ..HT..
    ......
    ......
    ......
    s.....
    .HT...
    ......
    ......
    ......
    s.....
    == D 1 ==
    ..T...
    .H....
    ......
    ......
    s.....
    == R 4 ==
    ..T...
    ..H...
    ......
    ......
    s.....
    ..T...
    ...H..
    ......
    ......
    s.....
    ......
    ...TH.
    ......
    ......
    s.....
    ......
    ....TH
    ......
    ......
    s.....
    == D 1 ==
    ......
    ....T.
    .....H
    ......
    s.....
    == L 5 ==
    ......
    ....T.
    ....H.
    ......
    s.....
    ......
    ....T.
    ...H..
    ......
    s.....
    ......
    ......
    ..HT..
    ......
    s.....
    ......
    ......
    .HT...
    ......
    s.....
    ......
    ......
    HT....
    ......
    s.....
    == R 2 ==
    ......
    ......
    .H....  (H covers T)
    ......
    s.....
    ......
    ......
    .TH...
    ......
    s.....
    ```
    After simulating the rope, you can count up all of the positions the
    *tail visited at least once*. In this diagram, `s` again marks the
    starting position (which the tail also visited) and `#` marks other
    positions the tail visited:
    ```
    ..##..
    ...##.
    .####.
    ....#.
    s###..
    ```
    So, there are `13` positions the tail visited at least once.
    Simulate your complete hypothetical series of motions. *How many
    positions does the tail of the rope visit at least once?*
    """
    movements = input_data
    answer = len(calculate_visited_positions((0, 0), movements))
    return answer


def solve_part_two(input_data):
    """Solve part two.

    A rope snaps! Suddenly, the river is getting a lot closer than you remember. The bridge is still there, but some of the ropes that broke are now whipping toward you as you fall through the air!

    The ropes are moving too quickly to grab; you only have a few seconds to choose how to arch your body to avoid being hit. Fortunately, your simulation can be extended to support longer ropes.

    Rather than two knots, you now must simulate a rope consisting of ten knots. One knot is still the head of the rope and moves according to the series of motions. Each knot further down the rope follows the knot in front of it using the same rules as before.

    Using the same series of motions as the above example, but with the knots marked H, 1, 2, ..., 9, the motions now occur as follows:

    == Initial State ==

    ......
    ......
    ......
    ......
    H.....  (H covers 1, 2, 3, 4, 5, 6, 7, 8, 9, s)

    == R 4 ==

    ......
    ......
    ......
    ......
    1H....  (1 covers 2, 3, 4, 5, 6, 7, 8, 9, s)

    ......
    ......
    ......
    ......
    21H...  (2 covers 3, 4, 5, 6, 7, 8, 9, s)

    ......
    ......
    ......
    ......
    321H..  (3 covers 4, 5, 6, 7, 8, 9, s)

    ......
    ......
    ......
    ......
    4321H.  (4 covers 5, 6, 7, 8, 9, s)

    == U 4 ==

    ......
    ......
    ......
    ....H.
    4321..  (4 covers 5, 6, 7, 8, 9, s)

    ......
    ......
    ....H.
    .4321.
    5.....  (5 covers 6, 7, 8, 9, s)

    ......
    ....H.
    ....1.
    .432..
    5.....  (5 covers 6, 7, 8, 9, s)

    ....H.
    ....1.
    ..432.
    .5....
    6.....  (6 covers 7, 8, 9, s)

    == L 3 ==

    ...H..
    ....1.
    ..432.
    .5....
    6.....  (6 covers 7, 8, 9, s)

    ..H1..
    ...2..
    ..43..
    .5....
    6.....  (6 covers 7, 8, 9, s)

    .H1...
    ...2..
    ..43..
    .5....
    6.....  (6 covers 7, 8, 9, s)

    == D 1 ==

    ..1...
    .H.2..
    ..43..
    .5....
    6.....  (6 covers 7, 8, 9, s)

    == R 4 ==

    ..1...
    ..H2..
    ..43..
    .5....
    6.....  (6 covers 7, 8, 9, s)

    ..1...
    ...H..  (H covers 2)
    ..43..
    .5....
    6.....  (6 covers 7, 8, 9, s)

    ......
    ...1H.  (1 covers 2)
    ..43..
    .5....
    6.....  (6 covers 7, 8, 9, s)

    ......
    ...21H
    ..43..
    .5....
    6.....  (6 covers 7, 8, 9, s)

    == D 1 ==

    ......
    ...21.
    ..43.H
    .5....
    6.....  (6 covers 7, 8, 9, s)

    == L 5 ==

    ......
    ...21.
    ..43H.
    .5....
    6.....  (6 covers 7, 8, 9, s)

    ......
    ...21.
    ..4H..  (H covers 3)
    .5....
    6.....  (6 covers 7, 8, 9, s)

    ......
    ...2..
    ..H1..  (H covers 4; 1 covers 3)
    .5....
    6.....  (6 covers 7, 8, 9, s)

    ......
    ...2..
    .H13..  (1 covers 4)
    .5....
    6.....  (6 covers 7, 8, 9, s)

    ......
    ......
    H123..  (2 covers 4)
    .5....
    6.....  (6 covers 7, 8, 9, s)

    == R 2 ==

    ......
    ......
    .H23..  (H covers 1; 2 covers 4)
    .5....
    6.....  (6 covers 7, 8, 9, s)

    ......
    ......
    .1H3..  (H covers 2, 4)
    .5....
    6.....  (6 covers 7, 8, 9, s)

    Now, you need to keep track of the positions the new tail, 9, visits. In this example, the tail never moves, and so it only visits 1 position. However, be careful: more types of motion are possible than before, so you might want to visually compare your simulated rope to the one above.

    Simulate your complete series of motions on a larger rope with ten knots. How many positions does the tail of the rope visit at least once?
    """

    def calculate_visited_positions(start_position, movements):
        """Calculate the positions visited in a movement"""
        # movement is (direction, count)
        visited_positions = {start_position: 1}
        rope_positions = [start_position for _ in range(0, 10)]
        for movement in movements:
            direction, count = movement
            for movement_count in range(0, count):
                rope_positions[0] = calculate_new_position(
                    rope_positions[0], direction)
                for knot in range(1, 10):
                    rope_positions[knot] = calculate_tail_position(
                        rope_positions[knot - 1], rope_positions[knot]
                    )
                tail_position = rope_positions[9]
                if tail_position in visited_positions:
                    visited_positions[tail_position] += 1
                else:
                    visited_positions[tail_position] = 1

        return visited_positions

    answer = len(calculate_visited_positions((0, 0), input_data))
    return answer


def main():
    puzzle = Puzzle(year=2022, day=9)
    parsed_data = parse(puzzle.input_data)
    answer_a = solve_part_one(parsed_data)
    if answer_a:
        puzzle.answer_a = answer_a
    parsed_data = parse(puzzle.input_data)
    answer_b = solve_part_two(parsed_data)
    if answer_b:
        puzzle.answer_b = answer_b


if __name__ == "__main__":
    main()
